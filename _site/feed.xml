<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YANTRIX</title>
    <description>This is portfolio of YANTRIX the official technical club of PUSSGRC,HOSHIARPUR, developed by Platform. It sharpen the  technical skills of college students.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 02 Jun 2019 15:42:33 +0530</pubDate>
    <lastBuildDate>Sun, 02 Jun 2019 15:42:33 +0530</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Blog: Infra-Red Remote Control Home Appliances</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Today’s engineering is based on reducing human efforts in affordable prices and this is mostly done by using “Wireless technology and Artificial Intelligence”. The manual switching of any home appliance is an inconvenient method for physically disabled or elders or even normal young guys when frequent switching operation is required. Thus the conventional method of switching operation has to be overcome by using a method of switching. This can be done by an advance switching method like a remote control for electronic home appliances.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;principle&quot;&gt;Principle&lt;/h3&gt;
&lt;p&gt;It is strictly based on the working of the infra-red rays. Infra-red radiations extends from the nominal red edge of the visible spectrum at 700nm to 1mm. This range of wavelengths corresponds to a frequency of approximately 430 THz to 300GHz.The Infra-red rays work just like a switch i.e. when the transmitted Infra-red rays will reach the receiver circuit , the circuit will get closed and the device will be turned on.&lt;/p&gt;
&lt;h3 id=&quot;circuit&quot;&gt;Circuit&lt;/h3&gt;
&lt;p&gt;It consists of two parts&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Transmitter circuit&lt;/li&gt;
  &lt;li&gt;Receiver circuit
    &lt;img src=&quot;/assets/blog/infrared/infraTransmitter.jpg&quot; alt=&quot;Transmitter circuit&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The transmitter circuit uses one IC i.e. NE555 which is a pulse generator the NE555 is used in its monostable state i.e. it will be generating a pulse and the time period of the pulse will be calculated by time constant of RC coupling. 
The 1st pin is ground hence connected to negative terminal of the battery. Second is trigger i.e. it will trigger the circuit when sufficient voltage is applied. The third pin is for output, forth for reset, 5th for control, 6th is for threshold voltage, 7th is discharge and 8th is VCC. 
In the circuit the NE555 will generate pulse when sufficient voltage is reaching at the 2nd pin of the IC and the pulse generated from the IC will complete the circuit as a result the IR transmitter will emit the Infra-red radiation.&lt;/p&gt;

&lt;h3 id=&quot;receiver-circuit&quot;&gt;Receiver circuit&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/blog/infrared/infraReciever.jpg&quot; alt=&quot;Receiver circuit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The circuit uses phototransistor TSOP 1738 and NE555 timer IC in its bistable state. The signal pin is connected to 2nd pin of NE555 which is the trigger pin of the IC as told earlier. As the phototransistor will receive the Infra-red radiation and this signal will be passed on to the trigger pin of the IC which will further switch on the circuit and the light will be switched on. As the NE555 is in bistable state it will be turned on when a pulse is generated then if second pulse will be given to the its trigger pin then NE555 will be turned off hence, the circuit will be turned off. Thus this will serve the purpose of remote control.&lt;/p&gt;

&lt;h3 id=&quot;future-scope&quot;&gt;Future scope&lt;/h3&gt;
&lt;p&gt;It can be used in places like hospitals or for places where handicapped, old or people who cannot move much resides. Research labs of radioactive substances can also use this. If used with counter IC 4017 we can make it usable for switching operation of large number of electrical appliances and can be used in big halls. It is very useful in robotics branch of science.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 03:50:46 +0530</pubDate>
        <link>http://localhost:4000/blog/electronics/sensors/robotics/Infrared-Remote-control-home-appliance</link>
        <guid isPermaLink="true">http://localhost:4000/blog/electronics/sensors/robotics/Infrared-Remote-control-home-appliance</guid>
        
        
        <category>blog</category>
        
        <category>Electronics</category>
        
        <category>Sensors</category>
        
        <category>Robotics</category>
        
      </item>
    
      <item>
        <title>Blog: All About Compiling And Running C Programs On Linux</title>
        <description>&lt;p&gt;Steps to Compile and Execute C Program in Linux Using GCC :–&lt;/p&gt;

&lt;p&gt;–&amp;gt; Before talking of compiling and running C program in Linux let’s see why C is so popular ever since it was created. He was the Dennis Ritchie who developed C language in 1969 to 1973. C was developed from the beginning as the system programming language for UNIX. Most of the UNIX kernel,&lt;!--more--&gt; and all of its supporting tools and libraries, were written in C. Initially, C was designed to implement the UNIX operating system. Later other folks found it useful for their programs without any hindrance, and they began using it. Even today, C is the first choice for system-level programming.&lt;/p&gt;

&lt;p&gt;This tutorial explains compilation and execution of C program is in detail.&lt;/p&gt;

&lt;p&gt;Compile C Program in Linux - A Classic example Hello World! :–&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;#include &lt;stdio.h&gt;
int main()
{
printf(&quot;hello, world!\n&quot;);
}
/* helloworld.c */&lt;/stdio.h&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;—&amp;gt; To compile and run this C program every part of the system has to perform in concert. In order to compile above C program in Linux, we will start right from the creation of the program. The ‘Hello World!’ program starts its life as a source file which is created with help of a text editor and saved as helloworld.c. The helloworld.c program code is stored in a file as a sequence of bytes. Each byte has a value corresponding to some character. The first byte has the value 35 that corresponds to the character ‘#’, for example. Likewise, the second byte has the integer value 105, which corresponds to the character ‘i’, and so on. The idea illustrates that all information in a system is represented as a bunch of bits.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To compile and run the C program helloworld.c, all C statements must be translated individually into a sequence of instructions that a machine can understand. These instructions are then packaged in a form called executable object program. There are other programs which perform this task to get the program running. On a UNIX/Linux system, the translation from source code to object code (executable) is performed by a compiler driver. Here we will compile C program by gcc.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The following command (provided that gcc is installed on your Linux box) compiles C program helloworld.c and creates an executable file called helloworld. Don’t forget to set appropriate permissions to helloworld.c, so that you won’t get execute permission errors.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[root@host ~]# gcc helloworld.c -o helloworld
While compiling helloworld.c the gcc compiler reads the source file helloworld.c and translates it into an executable helloworld. The compilation is performed in four sequential phases by the compilation system (a collection of four programs - preprocessor, compiler, assembler, and linker).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Now, let’s perform all four steps to compile and run C program one by one.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/blog/compile.gif&quot; alt=&quot;comile&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Preprocessing :—
During compilation of a C program the compilation is started off with preprocessing the directives (e.g., #include and #define). The preprocessor (cpp - c preprocessor) is a separate program in reality, but it is invoked automatically by the compiler. For example, the #include &lt;stdio.h&gt; command in line 1 of helloworld.c tells the preprocessor to read the contents of the system header file stdio.h and insert it directly into the program text. The result is another file typically with the .i suffix. In practice, the preprocessed file is not saved to disk unless the -save-temps option is used.
This is the first stage of compilation process where preprocessor directives (macros and header files are most common) are expanded. To perform this step gcc executes the following command internally.
[root@host ~]# cpp helloworld.c &amp;gt; helloworld.i
The result is a file helloworld.i that contains the source code with all macros expanded. If you execute the above command in isolation then the file helloworld.i will be saved to disk and you can see its content by vi or any other editor you have on your Linux system.&lt;/stdio.h&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Compilation :—
In this phase compilation proper takes place. The compiler (ccl) translates helloworld.i into helloworld.s. File helloworld.s contains assembly code. You can explicitly tell gcc to translate helloworld.i to helloworld.s by executing the following command.
[root@host ~]# gcc -S helloworld.i
The command line option -S tells the compiler to convert the preprocessed code to assembly language without creating an object file. After having created helloworld.s you can see the content of this file. While looking at assembly code you may note that the assembly code contains a call to the external function printf.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Assembly :—
Here, the assembler (as) translates helloworld.s into machine language instructions, and generates an object file helloworld.o. You can invoke the assembler at your own by executing the following command.
[root@host ~]# as helloworld.s -o helloworld.o
The above command will generate helloworld.o as it is specified with -o option. And, the resulting file contains the machine instructions for the classic “Hello World!” program, with an undefined reference to printf.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Linking :—
This is the final stage in compilation of “Hello World!” program. This phase links object files to produce final executable file. An executable file requires many external resources (system functions, C run-time libraries etc.). Regarding our “Hello World!” program you have noticed that it calls the printf function to print the ‘Hello World!’ message on console. This function is contained in a separate pre compiled object file printf.o, which must somehow be merged with our helloworld.o file. The linker (ld) performs this task for you. Eventually, the resulting file helloworld is produced, which is an executable. This is now ready to be loaded into memory and executed by the system.
[root@host ~]# ./helloworld
Output:
hello, world!&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;The entire linking process is handled transparently by gcc when invoked, as follows.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;[root@host ~]# gcc helloworld.c -o helloworld&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;During the whole compilation process there are other files also in role along with the source code file. If you see the very first statement of helloworld.c it is #include &lt;stdio.h&gt; (includes header file). Likewise, while compiling a C program you have to work with following types of files.&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Program Translation :—&lt;/strong&gt;
*Source code files :—&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;These files contain high level program code which can be read and understood by programmers. Such files carry .c extension by convention.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Header files :—&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;These types of files contain function declarations (also known as function prototypes) and various preprocessor statements. They are used to allow source code files to access externally-defined functions. As a convention header files have .h extension.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Object files :—&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;These files are produced as an intermediate output by the gcc compiler during program compilation. They consist of function definitions in binary form, but they are not executable by themselves. Object files end with .o extension by convention (on UNIX like operating systems), although on some operating systems e.g., Windows, and MS-DOS they often end in .obj.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Binary executables :—&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;These are produced as the output of a program called a linker. During the process of compiling and running C program the linker links together a number of object files to produce a binary file which can be directly executed. Binary executables have no special suffix on UNIX like operating systems, while they generally have .exe on Windows.
Along with above four types of files, while compiling a C program you can come across .a and .so, static and shared libraries respectively, but you would not normally deal with them directly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Last Word :—&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;In this article I explained compilation and execution process steps and stages of C program in Linux using gcc . Various phases during compilation and execution process of a C program take place, such as, preprocessing, compilation, assembly, and linking. Hope you have enjoyed reading this article. Please write us if you have any suggestion/comment or come across any error on this page. Thanks for reading!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don’t look even slightly believable.&lt;/p&gt;

</description>
        <pubDate>Sat, 19 Aug 2017 22:24:46 +0530</pubDate>
        <link>http://localhost:4000/blog/c/All-about-compiling-and-running-C-programs-on-linux</link>
        <guid isPermaLink="true">http://localhost:4000/blog/c/All-about-compiling-and-running-C-programs-on-linux</guid>
        
        
        <category>blog</category>
        
        <category>C</category>
        
      </item>
    
  </channel>
</rss>
